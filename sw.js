"use strict";(()=>{const CACHE_NAME = 'minis-repo-cache-2d00c51'; var IMAGE_CACHE="minis-images-v1",DATA_CACHE="minis-data-v1",IDB_NAME="minis-repo-sw",IDB_STORE="data-fallback",CRITICAL_ASSETS=["./","./index.html","./manifest.json","./apps/repo-icon.png"],IMAGE_PATTERNS=[/\/apps\/.*\.(png|jpg|jpeg|webp|gif)$/i,/objects\.githubusercontent\.com\//i,/raw\.githubusercontent\.com\/.*\.(png|jpg|jpeg|webp)$/i];var routes=[{name:"data",match:url=>url.pathname.endsWith("mini.json"),strategy:"stale-while-revalidate",cacheName:DATA_CACHE,maxAge:300},{name:"images",match:url=>IMAGE_PATTERNS.some(p=>p.test(url.href)),strategy:"stale-while-revalidate",cacheName:IMAGE_CACHE,maxEntries:80},{name:"json",match:url=>url.pathname.endsWith(".json"),strategy:"network-first",cacheName:CACHE_NAME},{name:"shell",match:(url,req)=>url.origin===self.location.origin&&req.mode!=="navigate",strategy:"cache-first",cacheName:CACHE_NAME,maxEntries:100}];self.addEventListener("install",event=>{event.waitUntil(caches.open(CACHE_NAME).then(cache=>Promise.allSettled(CRITICAL_ASSETS.map(url=>cache.add(url).catch(err=>{console.warn(`[SW] Pre-cache failed: ${url}`,err.message)}))))),self.skipWaiting()});self.addEventListener("activate",event=>{event.waitUntil(Promise.all([cleanOldCaches(),enableNavigationPreload()]).then(()=>self.clients.claim()).catch(()=>self.clients.claim()))});self.addEventListener("message",event=>{event.data&&(event.data.action==="skipWaiting"&&self.skipWaiting(),event.data.action==="checkForUpdate"&&self.registration.update().catch(()=>{}))});self.addEventListener("sync",event=>{let syncEvent=event;syncEvent.tag==="sync-data"&&syncEvent.waitUntil(refreshData())});async function refreshData(){try{let response=await fetch("./mini.json",{cache:"no-cache"});if(!response.ok)return;let newText=await response.text(),oldText=await idbGet(IDB_STORE,"mini.json"),changed=!oldText||oldText!==newText;if(await(await caches.open(DATA_CACHE)).put(new Request("./mini.json"),new Response(newText,{headers:{"Content-Type":"application/json",Date:new Date().toUTCString()}})),await idbPut(IDB_STORE,"mini.json",newText),changed){let clients=await self.clients.matchAll({type:"window"});for(let client of clients)client.postMessage({type:"DATA_UPDATED",timestamp:Date.now()})}}catch{}}self.addEventListener("fetch",event=>{let url=new URL(event.request.url);if(event.request.method!=="GET")return;if(event.request.mode==="navigate"){event.respondWith(handleNavigation(event));return}let route=routes.find(r=>r.match(url,event.request));if(route)switch(route.strategy){case"cache-first":event.respondWith(cacheFirstStrategy(event.request,route));break;case"network-first":event.respondWith(networkFirstStrategy(event.request,route));break;case"stale-while-revalidate":event.respondWith(staleWhileRevalidateStrategy(event.request,route));break}});async function handleNavigation(event){try{if(event.preloadResponse){let preload=await event.preloadResponse;if(preload)return cachePut(CACHE_NAME,event.request,preload.clone()).catch(()=>{}),preload}return await networkFirstStrategy(event.request,{name:"nav",match:()=>!0,strategy:"network-first",cacheName:CACHE_NAME})}catch{let cached=await caches.match("./index.html");return cached||buildOfflinePage()}}async function cacheFirstStrategy(request,route){let cached=await caches.match(request);if(cached&&!isCacheExpired(cached,route.maxAge))return cached;try{let response=await fetch(request);return response.ok&&shouldCache(response)&&cachePut(route.cacheName,request,response.clone(),route.maxEntries).catch(()=>{}),response}catch{return cached||(isImageRequest(request)?transparentPngResponse():new Response("Offline",{status:503,headers:{"Content-Type":"text/plain"}}))}}async function networkFirstStrategy(request,route){try{let response=await fetch(request);return response.ok&&shouldCache(response)&&cachePut(route.cacheName,request,response.clone(),route.maxEntries).catch(()=>{}),response}catch{let cached=await caches.match(request);if(cached)return cached;if(request.url.endsWith(".json")){let idbData=await idbGet(IDB_STORE,"mini.json");return idbData?new Response(idbData,{status:200,headers:{"Content-Type":"application/json"}}):new Response(JSON.stringify({error:"offline",message:"You appear to be offline."}),{status:503,headers:{"Content-Type":"application/json"}})}return new Response("Offline",{status:503,headers:{"Content-Type":"text/plain"}})}}async function staleWhileRevalidateStrategy(request,route){let cached=await(await caches.open(route.cacheName)).match(request),fetchPromise=fetch(request,route.name==="data"?{cache:"no-cache"}:{}).then(async response=>{if(response.ok&&shouldCache(response)&&(await cachePut(route.cacheName,request,response.clone(),route.maxEntries),route.name==="data")){let text=await response.clone().text(),oldText=await idbGet(IDB_STORE,"mini.json");if(await idbPut(IDB_STORE,"mini.json",text),!oldText||oldText!==text){let clients=await self.clients.matchAll({type:"window"});for(let client of clients)client.postMessage({type:"DATA_UPDATED",timestamp:Date.now()})}}return response}).catch(()=>null);if(cached)return fetchPromise.catch(()=>{}),cached;let networkResponse=await fetchPromise;if(networkResponse)return networkResponse;if(route.name==="data"){let idbData=await idbGet(IDB_STORE,"mini.json");return idbData?new Response(idbData,{status:200,headers:{"Content-Type":"application/json"}}):new Response(JSON.stringify({error:"offline",apps:[]}),{status:503,headers:{"Content-Type":"application/json"}})}return isImageRequest(request)?transparentPngResponse():new Response("Offline",{status:503,headers:{"Content-Type":"text/plain"}})}function shouldCache(response){let cc=response.headers.get("Cache-Control");return cc?!cc.includes("no-store"):!0}function isCacheExpired(response,maxAge){if(!maxAge)return!1;let dateHeader=response.headers.get("date");if(!dateHeader)return!1;let cacheDate=new Date(dateHeader).getTime();return Date.now()-cacheDate>maxAge*1e3}async function cachePut(cacheName,request,response,maxEntries){try{await(await caches.open(cacheName)).put(request,response),maxEntries&&trimCache(cacheName,maxEntries).catch(()=>{})}catch(err){console.warn("[SW] Cache put failed:",err.message)}}async function trimCache(cacheName,maxItems){try{let cache=await caches.open(cacheName),keys=await cache.keys();if(keys.length<=maxItems)return;let excess=keys.length-maxItems;for(let i=0;i<excess;i++)await cache.delete(keys[i])}catch{}}async function cleanOldCaches(){let managed=new Set([CACHE_NAME,IMAGE_CACHE,DATA_CACHE]),doClean=async()=>{let keys=await caches.keys();await Promise.all(keys.filter(k=>!managed.has(k)&&k.startsWith("minis-")).map(k=>caches.delete(k)))};if("locks"in navigator){let controller=new AbortController,timeout=setTimeout(()=>controller.abort(),5e3);try{await navigator.locks.request("sw-cache-cleanup",{signal:controller.signal},doClean)}catch{await doClean()}finally{clearTimeout(timeout)}}else await doClean()}async function enableNavigationPreload(){if(self.registration.navigationPreload)try{await self.registration.navigationPreload.enable()}catch{}}function idbOpen(){return new Promise((resolve,reject)=>{let req=indexedDB.open(IDB_NAME,1);req.onupgradeneeded=()=>{let db=req.result;db.objectStoreNames.contains(IDB_STORE)||db.createObjectStore(IDB_STORE,{keyPath:"key"})},req.onsuccess=()=>resolve(req.result),req.onerror=()=>reject(req.error)})}async function idbGet(store,key){try{let db=await idbOpen();return new Promise(resolve=>{let get=db.transaction(store,"readonly").objectStore(store).get(key);get.onsuccess=()=>resolve(get.result?.value??null),get.onerror=()=>resolve(null)})}catch{return null}}async function idbPut(store,key,value){try{let tx=(await idbOpen()).transaction(store,"readwrite");tx.objectStore(store).put({key,value,timestamp:Date.now()}),await new Promise(resolve=>{tx.oncomplete=()=>resolve(),tx.onerror=()=>resolve()})}catch{}}function isImageRequest(request){return/\.(png|jpg|jpeg|webp|gif)$/i.test(request.url)}function transparentPngResponse(){let png=new Uint8Array([137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,1,0,0,0,1,8,6,0,0,0,31,21,196,137,0,0,0,10,73,68,65,84,120,156,98,0,0,0,2,0,1,229,39,222,252,0,0,0,0,73,69,78,68,174,66,96,130]);return new Response(png.buffer,{status:200,headers:{"Content-Type":"image/png","Cache-Control":"no-store"}})}function buildOfflinePage(){let html=`<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="dark">
<title>Offline \u2014 Mini's Repo</title>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
body{background:#000;color:#f5f5f7;font-family:-apple-system,BlinkMacSystemFont,'SF Pro Display',system-ui,sans-serif;display:flex;align-items:center;justify-content:center;min-height:100vh;min-height:100dvh;text-align:center;padding:24px;-webkit-font-smoothing:antialiased}
.card{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.08);border-radius:20px;padding:40px 32px;max-width:360px;width:100%}
.icon{font-size:3em;margin-bottom:16px;line-height:1}
h1{font-size:1.4em;font-weight:700;margin-bottom:8px;letter-spacing:-0.3px}
p{color:#8e8e93;font-size:0.9em;line-height:1.5;margin-bottom:24px}
.url{font-family:'SF Mono',Menlo,Consolas,monospace;font-size:0.72em;color:#a78bfa;background:rgba(167,139,250,0.08);border:1px solid rgba(167,139,250,0.15);padding:8px 12px;border-radius:8px;word-break:break-all;margin-bottom:24px;display:block}
.actions{display:flex;flex-direction:column;gap:10px}
button{background:linear-gradient(135deg,#30d158,#2ac94e);color:#fff;border:none;border-radius:12px;padding:12px 28px;font-size:0.9em;font-weight:700;font-family:inherit;cursor:pointer;width:100%}
.secondary{background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.1);color:#c8c8cc}
</style>
</head>
<body>
<div class="card">
<div class="icon">&#x1F4F4;</div>
<h1>You're offline</h1>
<p>Mini's Repo needs a connection to load. Add the source URL directly to your app manager:</p>
<code class="url">https://OofMini.github.io/Minis-Repo/mini.json</code>
<div class="actions">
<button onclick="location.reload()">Try again</button>
<button class="secondary" onclick="history.back()">Go back</button>
</div>
</div>
</body>
</html>`;return new Response(html,{status:503,headers:{"Content-Type":"text/html; charset=utf-8","Cache-Control":"no-store"}})}})();
